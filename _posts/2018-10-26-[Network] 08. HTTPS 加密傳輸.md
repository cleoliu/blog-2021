---
layout: post
title: "[Network] 08. HTTPS 加密傳輸"
categories: [Network]
tags: [觀念, Network]
---


## 傳統密碼學

> 換置、取代。

- **換置**：字元位移。
- **取代**：用另一個字元取代。

<br/><br/>

## 近代密碼學

> 串流加密、區塊加密。

- **串流加密**：
    - 針對即時輸入的資料，如影音，此類 **非固定大小** 儲存，是以位元組（Byte）傳送，故針對 **位元組加密** 。
    - 用 **XOR** （真值表）加密。

        ![](https://s3.amazonaws.com/notejoy/note_images/111706.1.%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-23%20%E4%B8%8B%E5%8D%882.31.02.png)

- **區塊加密**：將資料 **切割成大小相同的區塊**，再進行演算法加密。

<br/><br/>

***

## 無加密

- HTTP

    ![](http://blog.upyun.com/wp-content/uploads/2017/03/http%E9%BB%91%E5%AE%A21.png)

<br/><br/>

- **攻擊方式**：
    - **客戶端發出的請求** 很容易被 **黑客截獲**（竊聽風險）。
    - 如果此時黑客 **冒充服務器**（冒充風險），則其可返回任意信息給客戶端（**篡改** 風險），而不被客戶端察覺。

<br/><br/>

***

## 對稱式加密 [1](https://blog.techbridge.cc/2017/04/16/simple-cryptography/)

> **加密** 和 **解密** 都是使用的 **同一個密鑰**。

- DES、AES-GCM、ChaCha20-Poly1305等。

- **加密方式**：

    ![](http://blog.upyun.com/wp-content/uploads/2017/03/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%862.png)

1. 產生密鑰：雙方 **共用一把密鑰**。
2. 加密：
    - 資料傳送時用這把 **密鑰** 和加密演算法將 **明文加密為密文**。
    - 只要 A 跟 B 都知道這把密鑰，A 要傳給 B 的時候，就用這個鑰匙加密。
3. 解密：B 拿到了之後再用同一個鑰匙解密，就可以互通有無。

<br/><br/>

- **攻擊方式**：
    - **密鑰被中間人攔截** 就沒戲了。

<br/><br/>

- **缺點**：
    - 不同的客戶端、服務器數量龐大，所以雙方都需要維護大量的密鑰，維護成本很高。
    - 因每個客戶端、服務器的安全級別不同，密鑰極易洩露。

<br/><br/>

***

## 非對稱式加密

> **加密使用的密鑰** 和 **解密使用的密鑰** 是 **不相同** 的，**公鑰** 和算法都是 **公開** 的，**私鑰** 是 **保密** 的。

- 非對稱加密算法 **性能較低**，但是 **安全性超強**，由於其加密特性，非對稱加密算法能加密的數據長度也是有限的。
- RSA、DSA、ECDSA、 DH、ECDHE。

- **加密方式**：
    ![](http://blog.upyun.com/wp-content/uploads/2017/03/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png)

1. 產生密鑰：**公鑰給對方**，**私鑰自己留**。
    - A 跟 B 都先生成一組公私鑰的 pair，**A 把 A 的公鑰傳給 B**，B 把 B 的公鑰傳給 A。
    - 現在 A 有他自己的私鑰跟 B 的公鑰，B 有他自己的私鑰跟 A 的公鑰。
2. 公鑰加密，私鑰解密：**A 要傳東西給 B** 就用 **B 的公鑰加密**，然後 B 拿到之後**用 B 自己的私鑰解密**。

<br/><br/>

- **攻擊方式**：
    - A 傳送 A 的公鑰給 B 時，被 C 攔截。生個公私鑰 pair，把 C 的公鑰 1 給 B，跟他說這是 A 的公鑰。
    - B 傳送 B 的公鑰給 A 時，被 C 攔截。生個公私鑰 pair，把 C 的公鑰 2 給 A，跟他說這是 B 的公鑰。
    - A 和 B 以為拿著對方的公鑰。（實際上為下圖）
    - 當 A 要傳給 B，A 以為他用 B 的公鑰加密（事實上他用了公鑰 C2），再用 A 的私鑰簽，想傳送給 B 但被 C 攔截。
    - C 用 A 的公鑰驗證，用私鑰 C2 解密之後，爽看內容，他就可改寫內容。之後用 B 的公鑰加密後再用私鑰 C1 簽章再傳給 B。
    - B 拿到後，他用 A 的公鑰確認（事實上這是公鑰 C1）然後再用他自己的私鑰解密。
    ![](https://blog.techbridge.cc/img/jyt0532/cryptography-step3.png)

<br/><br/>

- **解法**：
    - **A 拿到 B 的公鑰** 之後，去一個有公信力的 **第三方** 那邊問一下，嘿！這個真的是 B 的公鑰嗎。
    - A 要傳給 B 之前，把要傳的內容，先用 B 的公鑰加密再用 A 的私鑰簽，然後 B 用 A 的公鑰確認簽章再用 B 的私鑰解密內容。

<br/><br/>

***

## HTTPS [1](https://www.jyt0532.com/2017/03/08/https/)

> 用 **SSL證書**（Secure Sockets Layer）來加密原本的 http 協議。

> SSL 證書：公鑰、證書的發布機構、有效期、證書所有者、簽名 。

- 對稱式的效率比非對稱式的高很多，所以只要在 **一開始確認身份** 跟確認 **密鑰** 的時候用 **非對稱式** 就可以了。
    ![](http://blog.upyun.com/wp-content/uploads/2017/03/SSL%E8%AF%81%E4%B9%A6.png)
[1](http://support.upyun.com/hc/kb/article/1031843/)

- **流程**：
    - browser 是 A，server 是 B，A 發訊息跟 B 說我要看你的內容前：
    - _A_ 把 A 所有支援的 **加密方式告訴 B**，再 **給 B 一個隨機數 R1**。
    - _B_ 從所有的加密方式中選一種，然後把 **B 的身份** 訊息以 **證書** 的形式告訴 A（證書裡面包含了是哪個機構給 B 發證書的，還有 B 的公鑰），**自己保留私鑰**，然後 **給 A 另一個隨機數 R2**。
    - _A_ 拿到證書之後，就去 **問那個機構**，這個 B 真的是 B 嗎，<u>如果 A 信任這個機構，而且這個機構信任 B，那 A 就信任 B</u>，而每個 browser 有每個 browser 信任的機構，所以也是要慎選 browser 啊。（如果這個認證機構不可信任，或是這個機構對 B 的信任過期了，你的 browser 就會叫，要不要連線自己負責）
    - 如果可以信任的話，_A_ 會再生成一個 **隨機數 R3**，用剛剛 **B 給的公鑰**  **加密變成 C**，**把 C 丟給 B**。
    - _B_ 用 **私鑰對 C 解密** 得到 **R3**。
    - A 和 B 都有 R1 R2 R3 了，生成密鑰 K = R1+R2+R3，之後就可以兩邊用 **對稱式加密** 來說悄悄話了。

<br/><br/>

- **缺點**：
    - SSL 證書費用很高。
    - HTTPS 降低用戶訪問速度。（多次握手）
    - 由 HTTP 跳轉到 HTTPS 的方式增加了用戶訪問耗時。（多數網站採用 302 跳轉）

<br/><br/>

***

## 雜湊函數（Hash）

> 目的在於驗證資料傳輸過程，沒有因為外部因素導致不正確，或是遭到竄改。

- 輸入：傳送訊息。
- 加密：經過 Hash Function 編碼，成為訊息摘要。（訊息的特徵值）

<br/><br/>

***

[圖片](https://read01.com/8z5mJkO.html#.W5JXJhVR2Uk＿)

<br/><br/>